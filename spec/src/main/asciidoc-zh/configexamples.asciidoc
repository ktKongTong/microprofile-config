//
// Copyright (c) 2016-2017 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Contributors:
// Mark Struberg
// Emily Jiang

[[configexamples]]
// == Config Usage Examples


// An application can obtain its configuration programmatically via the `ConfigProvider`.
// In CDI enabled beans it can also get injected via `@Inject Config`.
// An application can then access its configured values via this `Config` instance.
== 配置使用示例


应用程序可以通过 `ConfigProvider` 以编程方式获取其配置。
在启用 CDI 的 bean 中，它还可以通过 `@Inject Config` 注入。
应用程序可以通过此 `Config` 实例访问其配置的值。

// === Simple Programmatic Example

=== 简单的编程示例

[source, java]
----
public class ConfigUsageSample {

    public void useTheConfig() {
        // 获取 Config 实例 get access to the Config instance
        Config config = ConfigProvider.getConfig();

        String serverUrl = config.getValue("acme.myprj.some.url", String.class);
        callToServer(serverUrl);

        // 或 or
        ConfigValue configServerUrl = config.getConfigValue("acme.myprj.some.url");
        callToServer(configServerUrl.getValue());
    }
}
----

// If you need to access a different server then you can e.g. change the configuration via a Java `-D` system property:

如果你需要访问不同的服务器，则可以通过 Java `-D` 系统属性更改配置，例如：

[source, text]
----
$> java -Dacme.myprj.some.url=http://other.server/other/endpoint -jar some.jar
----

// Note that this is only one example how to possibly configure your application.
// Another example is to register <<custom_configsources, Custom ConfigSources>> to e.g. pick up values from a database table, etc.

请注意，这只是配置应用程序的一种示例。
另一个示例是注册 <<custom_configsources, 自定义配置源>>，例如从数据库中获取值。

// If a config value is a comma(`,`) separated string, this value can be automatically converted to a multiple element array with `\` as the escape character.
// When specifying the property `myPets=dog,cat,dog\\,cat` in a config source, the following code snippet can be used to obtain an array.
如果配置值是逗号（`，`）分隔的字符串，则可以使用 `\` 作为转义字符将其自动转换为具有多个元素的数组。
在配置源中指定属性 `myPets=dog,cat,dog\\,cat` 时，可以使用以下代码片段来获取数组。

----
 String[] myPets = config.getValue("myPets", String[].class);
 //myPets = {"dog", "cat", "dog,cat"}
----


// === Simple Dependency Injection Example

// MicroProfile Config also provides ways to inject configured values into your beans using the `@Inject` and the `@ConfigProperty` qualifier.
// The `@Inject` annotation declares an injection point. When using this on a passivation capable bean, refer to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#passivating_scope[CDI Specification^]
// for more details on how to make the injection point to be passivation capable.

=== 简单的依赖注入示例

MicroProfile Config 还提供了使用 `@Inject` 和 `@ConfigProperty` 限定符将配置的值注入到 bean 中的方法。
`@Inject` 注释声明注入点。当在具有激活能力的 bean 上使用此注释时，请参阅 https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#passivating_scope[CDI 规范^]
以了解如何使注入点具有激活能力的详细信息。

[source, java]
----
@ApplicationScoped
public class InjectedConfigUsageSample {

    @Inject
    private Config config;

    //The property myprj.some.url must exist with a non-empty value, otherwise a
    //DeploymentException will be thrown.
    // myprj.some.url 属性必须存在且值不能为空，否则将抛出 DeploymentException。
    @Inject
    @ConfigProperty(name="myprj.some.url")
    private String someUrl;

//     You can also inject a configuration using the ConfigValue metadata object. The
//     configured value will not lead to a DeploymentException if the value is missing.
//     A default value can also be specified like any other configuration.
    // 你还可以使用 ConfigValue 元数据对象注入配置。如果缺少配置值，则不会导致 DeploymentException。
    // 可以像其他配置一样指定默认值。
    @Inject
    @ConfigProperty(name="myprj.another.url")
    private ConfigValue anotherUrl;

    //The following code injects an Optional value of myprj.some.port property.
    //Contrary to natively injecting the configured value, this will not lead to a
    //DeploymentException if the value is missing.
    //下面的代码注入了 myprj.some.port 属性的 Optional 值。
    //与本地注入配置值相反，缺少该值不会导致 DeploymentException。
    @Inject
    @ConfigProperty(name="myprj.some.port")
    private Optional<Integer> somePort;

    // You can also use the specialized Optional classes like OptionalInt,
    // OptionalDouble, or OptionalLong to perform the injection. The configured value
    // will not lead to a DeploymentException if the value is missing.
    // 你还可以使用专门的 Optional 类，如 OptionalInt、OptionalDouble 或 OptionalLong 来执行注入。
    // 缺少配置值不会导致 DeploymentException。
    @Inject
    @ConfigProperty(name="myprj.some.port")
    private OptionalInt somePort;

    //Injects a Provider for the value of myprj.some.dynamic.timeout property to
    //resolve the property dynamically. Each invocation to Provider#get() will
    //resolve the latest value from underlying Config.
    //The existence of configured values will get checked during start-up.
    //Instances of Provider<T> are guaranteed to be Serializable.
    // 注入 myprj.some.dynamic.timeout 属性的值的提供程序，以动态解析属性。
    // 每次调用 Provider#get() 时，都会从底层 Config 中解析最新的值。
    // 在启动期间将检查配置值的存在。
    // Provider<T> 的实例保证是可序列化的。
    @Inject
    @ConfigProperty(name="myprj.some.dynamic.timeout", defaultValue="100")
    private jakarta.inject.Provider<Long> timeout;

    //Injects a Supplier for the value of myprj.some.supplier.timeout property to
    //resolve the property dynamically. Each invocation to Supplier#get() will
    //resolve the latest value from underlying Config.
    //注入 myprj.some.supplier.timeout 属性的值的 Supplier，以动态解析属性。
    //每次调用 Supplier#get() 时，都会从底层 Config 中解析最新的值。
    @Inject
    @ConfigProperty(name="myprj.some.supplier.timeout", defaultValue="100")
    private java.util.function.Supplier<Long> timeout;

    //The following code injects an Array, List or Set for the `myPets` property,
    //where its value is a comma separated value ( myPets=dog,cat,dog\\,cat)
    //下面的代码注入了 `myPets` 属性的数组、列表或集合，其中其值是逗号分隔的值（myPets=dog,cat,dog\\,cat）
    @Inject @ConfigProperty(name="myPets") private String[] myArrayPets;
    @Inject @ConfigProperty(name="myPets") private List<String> myListPets;
    @Inject @ConfigProperty(name="myPets") private Set<String> mySetPets;
}
----

// === Config value conversion rules

// The table below defines the conversion rules, including some special edge case scenarios.

=== 配置值转换规则

下表定义了转换规则，包括一些特殊的边界场景。

[cols="1,1,1,2a",options="header"]
|===
// |Input String
|输入字符串
// |Output type
|输出类型
// |Method
|方法
// |behaviour
|行为

| "foo,bar"
| String
| getValue
| "foo,bar"

| "foo,bar"
| String[]
| getValue
| {"foo", "bar"}

| "foo,bar"
| String
| getOptionalValue
| Optional.of("foo,bar")

| "foo,bar"
| String[]
| getOptionalValue
| Optional.of({"foo","bar"})

| "foo,bar"
| String
| getOptionalValues
| Optional.of("foo", "bar")

| "foo,"
| String
| getValue
| "foo,"

| "foo,"
| String[]
| getValue
| {"foo"}

| "foo,"
| String
| getOptionalValue
| Optional.of("foo,")

| "foo,"
| String[]
| getOptionalValue
| Optional.of({"foo"})

| "foo,"
| String
| getOptionalValues
| Optional.of("foo")

| ",bar"
| String
| getValue
| ",bar"

| ",bar"
| String[]
| getValue
| {"bar"}

| ",bar"
| String
| getOptionalValue
| Optional.of(",bar")

| ",bar"
| String[]
| getOptionalValue
| Optional.of({"bar"})

| ",bar"
| String
| getOptionalValues
| Optional.of("bar")

| " " (space)
| String
| getValue
| " "

| " "(space)
| String[]
| getValue
| {" "}

| " "(space)
| String
| getOptionalValue
| Optional.of(" ")

| " "(space)
| String[]
| getOptionalValue
| Optional.of({" "})

| " "(space)
| String
| getOptionalValues
| Optional.of(" ")

| missing
| String
| getValue
| throws `NoSuchElementException`

| missing
| String[]
| getValue
| throws `NoSuchElementException`

| missing
| String
| getOptionalValue
| Optional.empty()

| missing
| String[]
| getOptionalValue
| Optional.empty()

| missing
| String
| getOptionalValues
| Optional.empty()

| ""
| String
| getValue
| throws `NoSuchElementException`

| ""
| String[]
| getValue
| throws `NoSuchElementException`


| ""
| String
| getOptionalValue
| Optional.empty()

| ""
| String[]
| getOptionalValue
| Optional.empty()

| ""
| String
| getOptionalValues
| Optional.empty()

| ","
| String
| getValue
| ","

| ","
| String[]
| getValue
| throws `NoSuchElementException`

| ","
| String
| getOptionalValue
| Optional.of(",")

| ","
| String[]
| getOptionalValue
| Optional.empty()

| ","
| String
| getOptionalValues
| Optional.empty()

| "\,"
| String
| getValue
| "\,"

| "\,"
| String[]
| getValue
| {","}


| "\,"
| String
| getOptionalValue
| Optional.of("\,")

| "\,"
| String[]
| getOptionalValue
| Optional.of({","})

| "\,"
| String
| getOptionalValues
| Optional.of(List.of(","))

| ",,"
| String
| getValue
| ",,"

| ",,"
| String[]
| getValue
| throws `NoSuchElementException`

| ",,"
| String
| getOptionalValue
| Optional.of(",,")

| ",,"
| String[]
| getOptionalValue
| Optional.empty()

| ",,"
| String
| getOptionalValues
| Optional.empty()


|===

// === Remove config properties
// Sometimes, there is a need to remove a property. This can be done by setting an empty value or a value causing the corresponding converter returning `null` in a config source.
// When injecting a property that has been deleted, `DeploymentException` will be thrown unless the return type is `Optional`.

=== 移除配置属性
有时候需要移除一个属性。这可以通过在配置源中设置一个空值或一个导致相应转换器返回 `null` 的值来完成。
当注入一个已经被删除的属性时，除非返回类型是 `Optional`，否则将抛出 `DeploymentException`。

// === Aggregate related properties into a CDI bean

// When injecting a number of related configuration properties, it can be tedious to repeat the statement of `ConfigProperty` in scatter places.
// Since they are related, it makes more sense to aggregate them into a single property class.

// MicroProfile Config provides a way to look up a number of configuration properties starting with the same prefix using the `@ConfigProperties` annotation, e.g. `ConfigProperties(prefix="myPrefix")`.
// When annotating a class with `@ConfigProperties` or `@ConfigProperties(prefix="myPrefix")`, any of its fields, regardless of the visibility, maps to a configuration property via the following mapping rules.

// * If the `prefix` is present, the field `x` maps to the configuration property `<prefix>.x`.
// * If the `prefix` is absent, the field `x` maps to the property name `x`.

// If the field name `x` needs to be different from the config property name `y`, use `@ConfigProperty(name="y")` to perform the transformation.
// If the prefix is present, the field `x` maps to the configuration property `<prefix>.y`, otherwise `y`.

// Considering the following config sources:

=== 将相关属性聚合到 CDI bean 中

当注入一系列相关的配置属性时，在分散的地方重复声明 `ConfigProperty` 会很繁琐。
因为它们是相关的，所以将它们聚合到一个单独的属性类中更有意义。

MicroProfile Config 提供了一种方法，可以使用 `@ConfigProperties` 注解查找以相同前缀开头的一系列配置属性，例如 `ConfigProperties(prefix="myPrefix")`。
当使用 `@ConfigProperties` 或 `@ConfigProperties(prefix="myPrefix")` 注解一个类时，任何它的字段（无论可见性如何）都通过以下映射规则映射到一个配置属性。

* 如果 `prefix` 存在，则字段 `x` 映射到配置属性 `<prefix>.x`。
* 如果 `prefix` 不存在，则字段 `x` 映射到属性名 `x`。

如果字段名 `x` 需要与配置属性名 `y` 不同，则使用 `@ConfigProperty(name="y")` 进行转换。
如果存在前缀，则字段 `x` 映射到配置属性 `<prefix>.y`，否则为 `y`。

考虑以下配置源：

[source, text]
----
config_ordinal = 120
server.host = localhost
server.port=9080
server.endpoint=query
server.old.location=London
----

[source, text]
----
config_ordinal = 150
client.host = myHost
client.port=9081
client.endpoint=shelf
client.old.location=Dublin
host = anotherHost
port=9082
endpoint=book
old.location=Berlin
----

// In order to retrieve the above properties in a single property class, you can use the `@ConfigProperties` annotation with a prefix.

要在单个属性类中获取上述属性，可以使用带有前缀的 `@ConfigProperties` 注解。

[source, java]
----

@ConfigProperties(prefix="server")
@Dependent
public class Details {
    public String host; // 配置属性 server.host 的值
    public int port;   // 配置属性 server.port 的值
    private String endpoint; // 配置属性 server.endpoint 的值
    public @ConfigProperty(name="old.location")
    String location; // 配置属性 server.old.location 的值
    public String getEndpoint() {
        return endpoint;
    }
}
----

// You can then use one of the following to retrieve the properties.

你可以使用以下任一方法来获取属性。

// ==== Programmatic lookup of the bean annotated with `@ConfigProperties`

// Since the class with `@ConfigProperties` is a CDI bean, you can use the programmatic lookup provided by CDI, e.g.

==== 使用 `@ConfigProperties` 注解的 bean 的编程查找

由于带有 `@ConfigProperties` 的类是一个 CDI bean，因此可以使用 CDI 提供的编程查找，例如：

[source, java]
----
Details details = CDI.current().select(Details.class, ConfigProperties.Literal.NO_PREFIX).get();
----

// ==== Inject the bean annotated with `@ConfigProperties`

==== 注入带有 `@ConfigProperties` 注解的 bean

[source, java]
----
@Inject
@ConfigProperties
Details serverDetails;
----

// The `serverDetails` will contain the following info, as the prefix is `server`:

`serverDetails` 将包含以下信息，因为前缀是 `server`：

[source, properties]
----
serverDetails.host -> server.host -> localhost
serverDetails.port -> server.port -> 9080
serverDetails.endpoint -> server.endpoint -> query
serverDetails.getLocation() -> server.old.location -> London
----

// Specify the prefix attribute on the annotation `@ConfigProperties` when injecting the bean.

// In this case, the prefix associated with `@ConfigProperties` on this injection point overrides the prefix specified on the bean class.

特定注解 `@ConfigProperties` 上的前缀属性在注入 bean 时。

在这种情况下，与此注入点上的 `@ConfigProperties` 关联的前缀覆盖了在 bean 类上指定的前缀。

[source, java]
----
@Inject
@ConfigProperties(prefix="client")
Details clientDetails;
----

// The prefix `client` overrides the prefix `server` on the `ServerDetails` bean. Therefore, this will retrieve the following properties.

前缀 `client` 覆盖了 `ServerDetails` bean 上的前缀 `server`。因此，它将检索以下属性。

[source, properties]
----
clientDetails.host -> client.host -> myHost
clientDetails.port -> client.port -> 9081
clientDetails.endpoint -> client.endpoint -> shelf
clientDetails.getLocation() -> client.old.location -> Dublin
----

// If `@ConfigProperties` has no associated prefix at the injection point, it defaults to the prefix set in the `Details`
// class, `server`.

如果 `@ConfigProperties` 在注入点上没有关联的前缀，则默认为 `Details` 类中设置的前缀 `server`。

[source, java]
----
@Inject
@ConfigProperties
Details details;
----

// Therefore, this will retrieve the following properties.

因此，它将检索以下属性。

[source, properties]
----
details.host -> server.host -> localhost
details.port -> server.port -> 9080
details.endpoint -> server.endpoint -> query
details.getLocation() -> server.old.location -> London
----

// If `@ConfigProperties` specifies an empty prefix at the injection point:

如果 `@ConfigProperties` 在注入点上指定了空前缀：

[source, java]
----
@Inject
@ConfigProperties(prefix = "")
Details details;
----

// It overrides the prefix set on the bean class `server` with an empty string `""`

它用空字符串 `""` 覆盖了 bean 类 `server` 上设置的前缀。

[source, properties]
----
details.host -> host -> anotherHost
details.port -> port -> 9082
details.endpoint -> endpoint -> book
details.getLocation() -> old.location -> Berlin
----

// ==== ConfigProperties bean class validation

// The configuration properties class should contain a zero-arg constructor. Otherwise, the behaviour is unspecified.
// When performing property lookup, a `DeploymentException` will be thrown for the following scenarios:

// 1. The property is missing and neither default value nor the property return type is optional.
// Use one of the following to fix the problem.
// ** Define a value for the property
// ** Supply a default value when defining the field.
// ** Use `@ConfigProperty` to provide a default value.
// ** Use `Optional<T>` or `OptionalInt`, `OptionalDouble`, `OptionalLong` as the type.

// 2. The property value cannot be converted to the specified type

// If any of the property cannot be found and there is neither default value nor property is not optional, `java.util.NoSuchElementException` will be thrown.
// In order to avoid this, you can supply a default value when defining the field. Alternatively, you can use `@ConfigProperty` to provide a default value.
// You can also use `Optional<T>` or OptionalInt, OptionalDouble, OptionalLong as the type. If any property values cannot be converted to the specified type, `java.lang.IllegalArgumentException` will be thrown.

==== ConfigProperties bean 类验证

配置属性类应包含一个零参数构造函数。否则，行为是未指定的。
当执行属性查找时，将在以下情况下抛出 `DeploymentException`：

1. 属性丢失，既没有默认值也没有属性返回类型是可选的。
使用以下任一方法来解决问题。
** 定义属性的值
** 定义字段时提供默认值。
** 使用 `@ConfigProperty` 提供默认值。
** 使用 `Optional<T>` 或 `OptionalInt`、`OptionalDouble`、`OptionalLong` 作为类型。

2. 无法将属性值转换为指定的类型

如果找不到任何属性，并且既没有默认值也没有属性是可选的，则将抛出 `java.util.NoSuchElementException`。
为了避免这种情况，可以在定义字段时提供默认值。或者，可以使用 `@ConfigProperty` 提供默认值。
您还可以使用 `Optional<T>` 或 OptionalInt、OptionalDouble、OptionalLong 作为类型。如果无法将任何属性值转换为指定的类型，则会抛出 `java.lang.IllegalArgumentException`。
